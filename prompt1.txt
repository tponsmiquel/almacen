Resumen de la Aplicación de Gestión de Almacén


Tecnologías Utilizadas

Backend: Python con Django

Base de Datos: MySQL

Frontend: React

Gráficos: Chart.js


Funcionalidades Principales

1) Gestión de Entradas en el Almacén


Registro de Entradas: Permite añadir entradas de artículos al almacén. Se puede seleccionar el artículo, ingresar la cantidad y la fecha de entrada.

Filtro de Búsqueda: Permite buscar entradas de artículos filtrando por artículo y un rango de fechas. Los resultados se muestran en una tabla.

2) 
Gestión de Salidas del Almacén


Registro de Salidas: Permite añadir salidas de artículos del almacén. Se puede seleccionar el cliente, ingresar la cantidad, seleccionar el artículo y la fecha de salida. 
Las salidas se pueden añadir en múltiples líneas antes de enviar el formulario.

Filtro de Búsqueda: Permite buscar salidas de artículos filtrando por cliente y un rango de fechas. Los resultados se muestran en una tabla.


3) Visualización de Gráficos


Permite visualizar gráficos del stock actual y su histórico basados en los artículos y las fechas seleccionadas.


Implementaciones Detalladas


1) Backend con Django


Modelos:

Article: Representa un artículo en el almacén.

Entry: Representa una entrada de un artículo en el almacén.

Exit: Representa una salida de un artículo del almacén.


Serializadores:

ArticleSerializer, EntrySerializer, ExitSerializer: Serializan y deserializan los datos para las API.


Vistas:
ArticleViewSet, EntryViewSet, ExitViewSet: Proveen las API para las operaciones CRUD en artículos, entradas y salidas.


URLs: Configuración de rutas para acceder a las API.


Comando de Gestión:
import_excel: Comando para importar datos de un archivo Excel a la base de datos.


2) Frontend con React


Componentes:

EntryList: Componente para la gestión de entradas. Permite registrar nuevas entradas y buscar entradas existentes.

ExitList: Componente para la gestión de salidas. Permite registrar nuevas salidas y buscar salidas existentes.

StockChart: Componente para la visualización de gráficos.


Servicios API:
api.js: Archivo con las funciones para interactuar con las API del backend (getArticles, getEntries, getExits, createEntry, createExit, getClients).


3) Gestión de Datos


Importación de Datos: Utilización de un comando de Django para importar registros desde un archivo Excel a la base de datos.

Filtrado de Datos: Implementación de filtros en los componentes EntryList y ExitList para buscar registros según criterios específicos (artículo, cliente, rango de fechas).


4) Interactividad


Formularios Dinámicos: Los formularios de entradas y salidas permiten agregar múltiples líneas de artículos antes de enviar los datos.

Mensajes de Éxito: Se muestran mensajes de éxito después de agregar entradas o salidas.

Estructura directorios

inventory/
	admin.py
	apps.py
	management/
		commands/
			import_excel.py
	migrations
	models.py
	serializers.py
	tests.py
	urls.py
	views.py
	__init__.py
	__pycache__
manage.py
PedidosAlmacenAmalia.xlsx
python
warehouse-frontend/
	.gitignore
	node_modules
	package-lock.json
	package.json
	public
	README.md
	src/
		App.css
		App.js
		App.test.js
		components/
			ArticleList.js
			EntryList.js
			ExitList.js
			StockChart.js
		index.css
		index.js
		logo.svg
		reportWebVitals.js
		services/
			api.js
		setupTests.js
warehouse_manager/
	asgi.py
	settings.py
	urls.py
	wsgi.py
	__init__.py
	__pycache__
*****

Este es el contenido de los principales archivos que forman la aplicación:
 inventory/models.py:
from django.db import models

class Article(models.Model):
    """
    Modelo que representa un artículo en el inventario.
    """
    name = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)

    def __str__(self):
        return self.name


class Client(models.Model):
    """
    Modelo que representa un cliente.
    """
    name = models.CharField(max_length=255)
    email = models.EmailField(unique=True, blank=True, null=True)
    phone = models.CharField(max_length=20, blank=True, null=True)
    address = models.TextField(blank=True, null=True)

    def __str__(self):
        return self.name


class Entry(models.Model):
    """
    Modelo que representa una entrada de artículos en el inventario.
    """
    article = models.ForeignKey(Article, on_delete=models.CASCADE)
    quantity = models.PositiveIntegerField()
    date = models.DateField()

    def __str__(self):
        return f'Entry of {self.quantity} units of {self.article.name}'


class Exit(models.Model):
    """
    Modelo que representa una salida de artículos del inventario para un cliente.
    """
    article = models.ForeignKey(Article, on_delete=models.CASCADE)
    client = models.ForeignKey(Client, on_delete=models.CASCADE)
    quantity = models.PositiveIntegerField()
    date = models.DateField()

    def __str__(self):
        return f'Exit of {self.quantity} units of {self.article.name} to {self.client.name}'

***
inventory/urls.py:
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ArticleViewSet, EntryViewSet, ExitViewSet, ClientViewSet

router = DefaultRouter()
router.register(r'articles', ArticleViewSet)
router.register(r'entries', EntryViewSet)
router.register(r'exits', ExitViewSet)
router.register(r'clients', ClientViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

***
warehouse_manager/settings.py:
import os 
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-7h+l(-czw!5g-18s6%m-t_9@%zo#j6n6*0koh-^@ay700y%5$t'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['127.0.0.1', 'localhost']

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'inventory',
    'rest_framework.authtoken',
    'dj_rest_auth',
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'dj_rest_auth.registration',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'allauth.account.middleware.AccountMiddleware',
]

# Configuración de autenticación
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication',
        'rest_framework.authentication.SessionAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
}

AUTHENTICATION_BACKENDS = [
    'django.contrib.auth.backends.ModelBackend',
    'allauth.account.auth_backends.AuthenticationBackend',
]

SITE_ID = 1

ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_USERNAME_REQUIRED = True
ACCOUNT_AUTHENTICATION_METHOD = 'username'
ACCOUNT_EMAIL_VERIFICATION = 'optional'

ROOT_URLCONF = 'warehouse_manager.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'inventory', 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
]

# Agrega la configuración de CSRF
CSRF_TRUSTED_ORIGINS = [
    "http://localhost:3000",
]

WSGI_APPLICATION = 'warehouse_manager.wsgi.application'

# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'laundry_warehouse',
        'USER': 'admin',
        'PASSWORD': '123456',
        'HOST': 'localhost',
        'PORT': '3306',
    }
}

# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True

STATIC_URL = '/static/'

# Archivos estáticos recogidos por collectstatic
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
***
src/services/api.js:
import axios from 'axios';

const API_URL = 'http://localhost:8000/api/';

export const getArticles = () => axios.get(`${API_URL}articles/`);
export const getEntries = () => axios.get(`${API_URL}entries/`);
export const getExits = () => axios.get(`${API_URL}exits/`);
export const createEntry = (entry) => axios.post(`${API_URL}entries/`, entry);
export const createExit = (exit) => axios.post(`${API_URL}exits/`, exit);
export const getClients = () => axios.get(`${API_URL}clients/`);

***
src/App.js:
// src/App.js
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import EntryList from './components/EntryList';
import ExitList from './components/ExitList';
import StockChart from './components/StockChart';
import Login from './components/Login';
import Register from './components/Register';
import Logout from './components/Logout'; // Importa el componente de Logout
import PrivateRoute from './components/PrivateRoute';
import './App.css';

function Home() {
  return (
    <div>
      <div className="section">
        <h2>Entradas</h2>
        <EntryList />
      </div>
      <div className="section">
        <h2>Salidas</h2>
        <ExitList />
      </div>
      <div className="section chart-section">
        <h2>Gráficos de Stock</h2>
        <StockChart />
      </div>
    </div>
  );
}

function App() {
  return (
    <Router>
      <div className="App">
        <header className="App-header">
          <h1>AMALIA. Gestión Almacén</h1>
          <Logout /> {/* Agrega el botón de Logout */}
        </header>
        <main>
          <Routes>
            <Route path="/login" element={<Login />} />
            <Route path="/register" element={<Register />} />
            <Route path="/" element={<PrivateRoute component={Home} />} />
          </Routes>
        </main>
      </div>
    </Router>
  );
}

export default App;

*****
src\components\ArticleList.js:

import React, { useEffect, useState } from 'react';
import { getArticles } from '../services/api';

const ArticleList = () => {
    const [articles, setArticles] = useState([]);

    useEffect(() => {
        getArticles().then(response => {
            console.log("Articles: ", response.data);
            setArticles(response.data || []);
        }).catch(error => {
            console.error('Error fetching articles:', error);
        });
    }, []);

    return (
        <div>
            <h2>Articles</h2>
            <p>{articles.length} articles loaded.</p>
            <ul>
                {articles.map(article => (
                    <li key={article.id}>{article.name} - {article.description}</li>
                ))}
            </ul>
        </div>
    );
};

export default ArticleList;

*****
src\components\EntryList.js:

import React, { useEffect, useState, useCallback } from 'react';
import { getEntries, createEntry, getArticles } from '../services/api';
import { Collapse, Button, Card } from 'react-bootstrap';

const EntryList = () => {
    const [entries, setEntries] = useState([]);
    const [filteredEntries, setFilteredEntries] = useState([]);
    const [articles, setArticles] = useState([]);
    const [date, setDate] = useState('');
    const [lines, setLines] = useState([{ article: '', quantity: '' }]);
    const [filterArticle, setFilterArticle] = useState('');
    const [filterStartDate, setFilterStartDate] = useState('');
    const [filterEndDate, setFilterEndDate] = useState('');
    const [successMessage, setSuccessMessage] = useState('');
    const [openSearch, setOpenSearch] = useState(false);
    const [openAdd, setOpenAdd] = useState(false);

    useEffect(() => {
        fetchEntries();
        fetchArticles();
    }, []);

    const fetchEntries = async () => {
        try {
            const response = await getEntries();
            console.log("Entries: ", response.data);
            setEntries(response.data || []);
        } catch (error) {
            console.error('Error fetching entries:', error);
        }
    };

    const fetchArticles = async () => {
        try {
            const response = await getArticles();
            console.log("Articles: ", response.data);
            const sortedArticles = response.data.sort((a, b) => a.name.localeCompare(b.name));
            setArticles(sortedArticles || []);
        } catch (error) {
            console.error('Error fetching articles:', error);
        }
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            for (const line of lines) {
                const entryData = { article: line.article, quantity: line.quantity, date };
                console.log('Enviando datos de entrada:', entryData); // Registro de depuración
                await createEntry(entryData);
            }
            setSuccessMessage('Entradas añadidas con éxito.');
            // Limpiar los campos del formulario
            setDate('');
            setLines([{ article: '', quantity: '' }]);
            // Ocultar el mensaje de éxito después de 3 segundos
            setTimeout(() => {
                setSuccessMessage('');
            }, 3000);
            fetchEntries(); // Actualizar la lista de entradas después de agregar una nueva
        } catch (error) {
            console.error('Error creando la entrada:', error.response.data); // Registro de depuración
        }
    };

    const handleFilter = useCallback(() => {
        let filtered = entries;

        if (filterArticle) {
            filtered = filtered.filter(entry => {
                const article = articles.find(a => a.id === entry.article);
                return article && article.name === filterArticle;
            });
        }

        if (filterStartDate && filterEndDate) {
            filtered = filtered.filter(entry => entry.date >= filterStartDate && entry.date <= filterEndDate);
        }

        setFilteredEntries(filtered);
    }, [entries, articles, filterArticle, filterStartDate, filterEndDate]);

    const resetFilters = () => {
        setFilterArticle('');
        setFilterStartDate('');
        setFilterEndDate('');
        setFilteredEntries([]);
    };

    const handleLineChange = (index, field, value) => {
        const newLines = [...lines];
        newLines[index][field] = value;
        setLines(newLines);
    };

    const addLine = () => {
        setLines([...lines, { article: '', quantity: '' }]);
    };

    const removeLine = (index) => {
        const newLines = lines.filter((_, i) => i !== index);
        setLines(newLines);
    };

    return (
        <div className="section container">
            <div className="section-card mb-4">
                <h5 onClick={() => setOpenSearch(!openSearch)}
                    aria-controls="search-collapse"
                    aria-expanded={openSearch}
                    style={{ cursor: 'pointer' }}>
                    Buscador de entradas en almacén
                </h5>
                <Collapse in={openSearch}>
                    <div id="search-collapse">
                        <div className="filters-container row justify-content-center">
                            <div className="col-md-4">
                                <select className="form-control" value={filterArticle} onChange={e => setFilterArticle(e.target.value)}>
                                    <option value="">Seleccionar artículo</option>
                                    {articles.map(article => (
                                        <option key={article.id} value={article.name}>
                                            {article.name}
                                        </option>
                                    ))}
                                </select>
                            </div>
                            <div className="col-md-3">
                                <input 
                                    type="date" 
                                    className="form-control" 
                                    placeholder="Desde" 
                                    value={filterStartDate} 
                                    onChange={e => setFilterStartDate(e.target.value)} 
                                />
                            </div>
                            <div className="col-md-3">
                                <input 
                                    type="date" 
                                    className="form-control" 
                                    placeholder="Hasta" 
                                    value={filterEndDate} 
                                    onChange={e => setFilterEndDate(e.target.value)} 
                                />
                            </div>
                            <div className="col-md-2 d-flex justify-content-between">
                                <button className="btn btn-primary" onClick={handleFilter}>Iniciar búsqueda</button>
                                <button className="btn btn-secondary ml-2" onClick={resetFilters}>Resetear</button>
                            </div>
                        </div>
                        {filteredEntries.length > 0 && (
                            <table className="styled-table table table-striped mt-4">
                                <thead>
                                    <tr>
                                        <th>Artículo</th>
                                        <th>Cantidad</th>
                                        <th>Fecha</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {filteredEntries.map(entry => (
                                        <tr key={entry.id}>
                                            <td>{articles.find(a => a.id === entry.article)?.name || 'Desconocido'}</td>
                                            <td>{entry.quantity}</td>
                                            <td>{entry.date}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        )}
                    </div>
                </Collapse>
            </div>
            
            <div className="section-card">
                <h5 onClick={() => setOpenAdd(!openAdd)}
                    aria-controls="add-collapse"
                    aria-expanded={openAdd}
                    style={{ cursor: 'pointer' }}>
                    Añadir nueva entrada en almacén
                </h5>
                <Collapse in={openAdd}>
                    <div id="add-collapse">
                        <div className="form-container">
                            <form onSubmit={handleSubmit} className="text-center">
                                <div className="form-group row justify-content-center">
                                    <label className="col-md-2 col-form-label"><b>Fecha</b></label>
                                    <div className="col-md-4">
                                        <input 
                                            type="date" 
                                            className="form-control" 
                                            value={date} 
                                            onChange={e => setDate(e.target.value)} 
                                            required 
                                        />
                                    </div>
                                </div>
                                {lines.map((line, index) => (
                                    <div key={index} className="form-group row justify-content-center">
                                        <div className="col-md-4">
                                            <select className="form-control" value={line.article} onChange={e => handleLineChange(index, 'article', e.target.value)} required>
                                                <option value="">Seleccionar artículo</option>
                                                {articles.map(article => (
                                                    <option key={article.id} value={article.id}>
                                                        {article.name}
                                                    </option>
                                                ))}
                                            </select>
                                        </div>
                                        <div className="col-md-3">
                                            <input 
                                                type="number" 
                                                className="form-control" 
                                                placeholder="Cantidad" 
                                                value={line.quantity} 
                                                onChange={e => handleLineChange(index, 'quantity', e.target.value)} 
                                                required 
                                            />
                                        </div>
                                        <div className="col-md-5 d-flex justify-content-center align-items-center">
                                            <button type="button" className="btn btn-info mx-2" onClick={addLine}>+</button>
                                            <button type="button" className="btn btn-danger mx-2" onClick={() => removeLine(index)}>Eliminar</button>
                                        </div>
                                    </div>
                                ))}
                                <div className="form-group row justify-content-center">
                                    <div className="col-md-2">
                                        <button type="submit" className="btn btn-success">Añadir entrada/s</button>
                                    </div>
                                </div>
                            </form>
                            {successMessage && <p className="success-message text-center">{successMessage}</p>}
                        </div>
                    </div>
                </Collapse>
            </div>
        </div>
    );
};

export default EntryList;

*****
src\components\ExitList.js:

import React, { useEffect, useState } from 'react';
import { getExits, createExit, getArticles, getClients } from '../services/api';
import { Collapse, Button, Card } from 'react-bootstrap';

const ExitList = () => {
    const [exits, setExits] = useState([]);
    const [filteredExits, setFilteredExits] = useState([]);
    const [articles, setArticles] = useState([]);
    const [clients, setClients] = useState([]);
    const [client, setClient] = useState('');
    const [date, setDate] = useState('');
    const [lines, setLines] = useState([{ article: '', quantity: '' }]);
    const [filterClient, setFilterClient] = useState('');
    const [filterStartDate, setFilterStartDate] = useState('');
    const [filterEndDate, setFilterEndDate] = useState('');
    const [successMessage, setSuccessMessage] = useState('');
    const [openSearch, setOpenSearch] = useState(false);
    const [openAdd, setOpenAdd] = useState(false);

    useEffect(() => {
        fetchArticles();
        fetchClients();
        fetchExits();
    }, []);

    const fetchExits = async () => {
        try {
            const response = await getExits();
            console.log("Exits: ", response.data);
            setExits(response.data || []);
            setFilteredExits([]); // Inicialmente, no mostrar salidas filtradas
        } catch (error) {
            console.error('Error fetching exits:', error);
        }
    };

    const fetchArticles = async () => {
        try {
            const response = await getArticles();
            console.log("Articles: ", response.data);
            const sortedArticles = response.data.sort((a, b) => a.name.localeCompare(b.name));
            setArticles(sortedArticles || []);
        } catch (error) {
            console.error('Error fetching articles:', error);
        }
    };

    const fetchClients = async () => {
        try {
            const response = await getClients();
            console.log("Clients: ", response.data);
            setClients(response.data || []);
        } catch (error) {
            console.error('Error fetching clients:', error);
        }
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            for (const line of lines) {
                await createExit({ article: line.article, client, quantity: line.quantity, date });
            }
            setSuccessMessage('Salidas añadidas con éxito.');
            // Limpiar los campos del formulario
            setClient('');
            setDate('');
            setLines([{ article: '', quantity: '' }]);
            // Ocultar el mensaje de éxito después de 3 segundos
            setTimeout(() => {
                setSuccessMessage('');
            }, 3000);
            fetchExits(); // Actualizar la lista de salidas después de agregar una nueva
        } catch (error) {
            console.error('Error creating exit:', error);
        }
    };

    const handleFilter = () => {
        let filtered = exits;

        if (filterClient) {
            filtered = filtered.filter(exit => exit.client === filterClient);
        }

        if (filterStartDate && filterEndDate) {
            filtered = filtered.filter(exit => exit.date >= filterStartDate && exit.date <= filterEndDate);
        }

        setFilteredExits(filtered.map(exit => ({
            ...exit,
            articleName: getArticleName(exit.article)
        })));
    };

    const getArticleName = (articleId) => {
        const article = articles.find(a => a.id === articleId);
        return article ? article.name : 'Desconocido';
    };

    const resetFilters = () => {
        setFilterClient('');
        setFilterStartDate('');
        setFilterEndDate('');
        setFilteredExits([]);
    };

    const handleLineChange = (index, field, value) => {
        const newLines = [...lines];
        newLines[index][field] = value;
        setLines(newLines);
    };

    const addLine = () => {
        setLines([...lines, { article: '', quantity: '' }]);
    };

    const removeLine = (index) => {
        const newLines = lines.filter((_, i) => i !== index);
        setLines(newLines);
    };

    return (
        <div className="section container">
            <div className="section-card mb-4">
                <h5 onClick={() => setOpenSearch(!openSearch)}
                    aria-controls="search-collapse"
                    aria-expanded={openSearch}
                    style={{ cursor: 'pointer' }}>
                    Buscador de salidas del almacén
                </h5>
                <Collapse in={openSearch}>
                    <div id="search-collapse">
                        <div className="filters-container row">
                            <div className="col-md-4">
                                <select className="form-control" value={filterClient} onChange={e => setFilterClient(e.target.value)}>
                                    <option value="">Seleccionar cliente</option>
                                    {clients.map(client => (
                                        <option key={client.id} value={client.name}>
                                            {client.name}
                                        </option>
                                    ))}
                                </select>
                            </div>
                            <div className="col-md-3">
                                <input 
                                    type="date" 
                                    className="form-control" 
                                    placeholder="Desde" 
                                    value={filterStartDate} 
                                    onChange={e => setFilterStartDate(e.target.value)} 
                                />
                            </div>
                            <div className="col-md-3">
                                <input 
                                    type="date" 
                                    className="form-control" 
                                    placeholder="Hasta" 
                                    value={filterEndDate} 
                                    onChange={e => setFilterEndDate(e.target.value)} 
                                />
                            </div>
                            <div className="col-md-2">
                                <button className="btn btn-primary" onClick={handleFilter}>Iniciar búsqueda</button>
                                <button className="btn btn-secondary ml-2" onClick={resetFilters}>Resetear filtros</button>
                            </div>
                        </div>
                        {filteredExits.length > 0 && (
                            <table className="styled-table table table-striped mt-4">
                                <thead>
                                    <tr>
                                        <th>Artículo</th>
                                        <th>Cliente</th>
                                        <th>Cantidad</th>
                                        <th>Fecha</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {filteredExits.map(exit => (
                                        <tr key={exit.id}>
                                            <td>{exit.articleName}</td>
                                            <td>{exit.client}</td>
                                            <td>{exit.quantity}</td>
                                            <td>{exit.date}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        )}
                    </div>
                </Collapse>
            </div>
            
            <div className="section-card">
    <h5 onClick={() => setOpenAdd(!openAdd)}
        aria-controls="add-collapse"
        aria-expanded={openAdd}
        style={{ cursor: 'pointer' }}>
        Añadir nueva salida del almacén
    </h5>
    <Collapse in={openAdd}>
        <div id="add-collapse">
            <div className="form-container">
                <form onSubmit={handleSubmit} className="text-center">
                    <div className="form-group row justify-content-center">
                        <label className="col-md-2 col-form-label"><b>Cliente</b></label>
                        <div className="col-md-4">
                            <select className="form-control" value={client} onChange={e => setClient(e.target.value)} required>
                                <option value="">Seleccionar cliente</option>
                                {clients.map(client => (
                                    <option key={client.id} value={client.name}>
                                        {client.name}
                                    </option>
                                ))}
                            </select>
                        </div>
                        <label className="col-md-2 col-form-label"><b>Fecha</b></label>
                        <div className="col-md-4">
                            <input 
                                type="date" 
                                className="form-control" 
                                value={date} 
                                onChange={e => setDate(e.target.value)} 
                                required 
                            />
                        </div>
                    </div>
                    {lines.map((line, index) => (
                        <div key={index} className="form-group row justify-content-center">
                            <div className="col-md-4">
                                <select className="form-control" value={line.article} onChange={e => handleLineChange(index, 'article', e.target.value)} required>
                                    <option value="">Seleccionar artículo</option>
                                    {articles.map(article => (
                                        <option key={article.id} value={article.id}>
                                            {article.name}
                                        </option>
                                    ))}
                                </select>
                            </div>
                            <div className="col-md-3">
                                <input 
                                    type="number" 
                                    className="form-control" 
                                    placeholder="Cantidad" 
                                    value={line.quantity} 
                                    onChange={e => handleLineChange(index, 'quantity', e.target.value)} 
                                    required 
                                />
                            </div>
                            <div className="col-md-5 d-flex justify-content-center align-items-center">
                                <button type="button" className="btn btn-info mx-2" onClick={addLine}>+</button>
                                <button type="button" className="btn btn-danger mx-2" onClick={() => removeLine(index)}>Eliminar</button>
                            </div>
                        </div>
                    ))}
                    <div className="form-group row justify-content-center">
                        <div className="col-md-2">
                            <button type="submit" className="btn btn-success">Enviar pedido</button>
                        </div>
                    </div>
                </form>
                {successMessage && <p className="success-message text-center">{successMessage}</p>}
            </div>
        </div>
    </Collapse>
</div>
        </div>
    );
};

export default ExitList;

*****
src\components\Login.js:

import React, { useState } from 'react';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';

function Login() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const navigate = useNavigate();

  const handleSubmit = async (event) => {
    event.preventDefault();
    setError('');

    try {
      const response = await axios.post('http://localhost:8000/api/auth/login/', {
        username,
        password
      });
      localStorage.setItem('token', response.data.key); // Guarda el token en localStorage
      navigate('/');  // Redirigir a la página principal
    } catch (error) {
      setError('Login failed!');
      console.error('Login failed:', error.response ? error.response.data : error.message);
    }
  };

  return (
    <div>
      <h2>Login</h2>
      <form onSubmit={handleSubmit}>
        {error && <p style={{ color: 'red' }}>{error}</p>}
        <div>
          <label>Username:</label>
          <input
            type="text"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
          />
        </div>
        <div>
          <label>Password:</label>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
        </div>
        <button type="submit">Login</button>
      </form>
    </div>
  );
}

export default Login;

*****

src\components\Logout.js:

import React from 'react';
import { useNavigate } from 'react-router-dom';

const Logout = () => {
  const navigate = useNavigate();

  const handleLogout = () => {
    localStorage.removeItem('token'); // Eliminar el token del localStorage
    navigate('/login'); // Redirigir al usuario a la página de inicio de sesión
  };

  return (
    <button className="logout-button" onClick={handleLogout}>
      Cerrar sesión
    </button>
  );
};

export default Logout;

*****

src\components\Register.js:

import React, { useState } from 'react';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';

function Register() {
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password1, setPassword1] = useState('');
  const [password2, setPassword2] = useState('');
  const [error, setError] = useState('');
  const navigate = useNavigate();

  const handleSubmit = async (event) => {
    event.preventDefault();
    setError(''); // Clear previous error messages

    if (password1 !== password2) {
      setError('Passwords do not match');
      return;
    }

    try {
      const response = await axios.post('http://localhost:8000/api/auth/registration/', {
        username,
        email,
        password1,
        password2
      });
      localStorage.setItem('token', response.data.key);
      navigate('/entries');
    } catch (error) {
      setError('Registration failed!');
      console.error('Registration failed:', error.response ? error.response.data : error.message); // Log detallado
    }
  };

  return (
    <div>
      <h2>Register</h2>
      <form onSubmit={handleSubmit}>
        {error && <p style={{ color: 'red' }}>{error}</p>}
        <div>
          <label>Username:</label>
          <input
            type="text"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
          />
        </div>
        <div>
          <label>Email:</label>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
          />
        </div>
        <div>
          <label>Password:</label>
          <input
            type="password"
            value={password1}
            onChange={(e) => setPassword1(e.target.value)}
          />
        </div>
        <div>
          <label>Confirm Password:</label>
          <input
            type="password"
            value={password2}
            onChange={(e) => setPassword2(e.target.value)}
          />
        </div>
        <button type="submit">Register</button>
      </form>
    </div>
  );
}

export default Register;

*****
src\components\StockChart.js:

import React, { useEffect, useState } from 'react';
import { Bar } from 'react-chartjs-2';
import { Chart as ChartJS, CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend } from 'chart.js';
import { getEntries, getExits, getArticles, getClients } from '../services/api';
import { Form, Col, Row, Button, Collapse } from 'react-bootstrap';
import moment from 'moment';

// Registrar los componentes necesarios
ChartJS.register(
    CategoryScale,
    LinearScale,
    BarElement,
    Title,
    Tooltip,
    Legend
);

const StockChart = () => {
    const [data, setData] = useState(null);
    const [articles, setArticles] = useState([]);
    const [clients, setClients] = useState([]);
    const [selectedArticle, setSelectedArticle] = useState('');
    const [selectedClient, setSelectedClient] = useState('');
    const [dateRange, setDateRange] = useState({ start: '', end: '' });
    const [chartType, setChartType] = useState('entries'); // 'entries', 'exits', or 'both'
    const [xAxisGrouping, setXAxisGrouping] = useState('articles'); // 'articles', 'clients', 'dates'
    const [dateGrouping, setDateGrouping] = useState('daily'); // 'daily', 'biweekly', 'monthly', 'yearly'
    const [open, setOpen] = useState(false); // Estado de colapso

    useEffect(() => {
        const fetchData = async () => {
            try {
                const [entriesResponse, exitsResponse, articlesResponse, clientsResponse] = await Promise.all([
                    getEntries(),
                    getExits(),
                    getArticles(),
                    getClients()
                ]);

                const sortedArticles = articlesResponse.data.sort((a, b) => a.name.localeCompare(b.name));
                setArticles(sortedArticles || []);
                setClients(clientsResponse.data || []);

                processChartData(entriesResponse.data || [], exitsResponse.data || []);
            } catch (error) {
                console.error('Error fetching data:', error);
            }
        };

        fetchData();
    }, []);

    const processChartData = (entries, exits) => {
        let filteredEntries = entries;
        let filteredExits = exits;

        if (selectedArticle) {
            filteredEntries = filteredEntries.filter(entry => entry.article === parseInt(selectedArticle));
            filteredExits = filteredExits.filter(exit => exit.article === parseInt(selectedArticle));
        }

        if (selectedClient) {
            filteredEntries = filteredEntries.filter(entry => entry.client === parseInt(selectedClient));
            filteredExits = filteredExits.filter(exit => exit.client === parseInt(selectedClient));
        }

        if (dateRange.start && dateRange.end) {
            filteredEntries = filteredEntries.filter(entry => entry.date >= dateRange.start && entry.date <= dateRange.end);
            filteredExits = filteredExits.filter(exit => exit.date >= dateRange.start && exit.date <= dateRange.end);
        }

        const labels = [];
        const entryData = [];
        const exitData = [];

        if (xAxisGrouping === 'articles') {
            const articlesMap = new Map();
            articles.forEach(article => {
                articlesMap.set(article.id, { name: article.name, entryCount: 0, exitCount: 0 });
            });

            filteredEntries.forEach(entry => {
                if (articlesMap.has(entry.article)) {
                    articlesMap.get(entry.article).entryCount += entry.quantity;
                }
            });

            filteredExits.forEach(exit => {
                if (articlesMap.has(exit.article)) {
                    articlesMap.get(exit.article).exitCount += exit.quantity;
                }
            });

            articlesMap.forEach((value, key) => {
                labels.push(value.name);
                entryData.push(value.entryCount);
                exitData.push(value.exitCount);
            });

        } else if (xAxisGrouping === 'clients') {
            const clientsMap = new Map();
            clients.forEach(client => {
                clientsMap.set(client.id, { name: client.name, entryCount: 0, exitCount: 0 });
            });

            filteredEntries.forEach(entry => {
                if (clientsMap.has(entry.client)) {
                    clientsMap.get(entry.client).entryCount += entry.quantity;
                }
            });

            filteredExits.forEach(exit => {
                if (clientsMap.has(exit.client)) {
                    clientsMap.get(exit.client).exitCount += exit.quantity;
                }
            });

            clientsMap.forEach((value, key) => {
                labels.push(value.name);
                entryData.push(value.entryCount);
                exitData.push(value.exitCount);
            });
        } else if (xAxisGrouping === 'dates') {
            const datesMap = new Map();

            const addToMap = (date, type, quantity) => {
                let key;
                if (dateGrouping === 'yearly') {
                    key = moment(date).format('YYYY');
                } else if (dateGrouping === 'monthly') {
                    key = moment(date).format('YYYY-MM');
                } else if (dateGrouping === 'biweekly') {
                    const week = moment(date).week();
                    const year = moment(date).year();
                    key = `${year}-W${Math.ceil(week / 2)}`;
                } else {
                    key = moment(date).format('YYYY-MM-DD');
                }

                if (!datesMap.has(key)) {
                    datesMap.set(key, { entryCount: 0, exitCount: 0 });
                }
                datesMap.get(key)[type] += quantity;
            };

            filteredEntries.forEach(entry => {
                addToMap(entry.date, 'entryCount', entry.quantity);
            });

            filteredExits.forEach(exit => {
                addToMap(exit.date, 'exitCount', exit.quantity);
            });

            const sortedDates = Array.from(datesMap.keys()).sort();

            sortedDates.forEach(key => {
                labels.push(key);
                entryData.push(datesMap.get(key).entryCount);
                exitData.push(datesMap.get(key).exitCount);
            });
        }

        const datasets = [];

        if (chartType === 'entries' || chartType === 'both') {
            datasets.push({
                label: 'Entradas',
                data: entryData,
                backgroundColor: 'rgba(75, 192, 192, 0.6)',
            });
        }

        if (chartType === 'exits' || chartType === 'both') {
            datasets.push({
                label: 'Salidas',
                data: exitData,
                backgroundColor: 'rgba(255, 99, 132, 0.6)',
            });
        }

        setData({
            labels,
            datasets
        });
    };

    const handleFilterChange = () => {
        // Fetch entries and exits again and re-process the data
        getEntries().then(entriesResponse => {
            getExits().then(exitsResponse => {
                processChartData(entriesResponse.data || [], exitsResponse.data || []);
            });
        });
    };

    // Mostrar un mensaje de carga mientras se cargan los datos
    if (!data) {
        return <div>Loading...</div>;
    }

    return (
        <div className="section-card">
            <h5 onClick={() => setOpen(!open)}
                aria-controls="chart-collapse"
                aria-expanded={open}
                style={{ cursor: 'pointer' }}>
                Visor de gráficos
            </h5>
            <Collapse in={open}>
                <div id="chart-collapse" className="chart-section">
                    <Form>
                        <Row className="mb-3">
                            <Col>
                                <Form.Group controlId="articleSelect">
                                    <Form.Label>Artículo</Form.Label>
                                    <Form.Control as="select" value={selectedArticle} onChange={e => setSelectedArticle(e.target.value)}>
                                        <option value="">Seleccionar artículo</option>
                                        {articles.map(article => (
                                            <option key={article.id} value={article.id}>{article.name}</option>
                                        ))}
                                    </Form.Control>
                                </Form.Group>
                            </Col>
                            <Col>
                                <Form.Group controlId="clientSelect">
                                    <Form.Label>Cliente</Form.Label>
                                    <Form.Control as="select" value={selectedClient} onChange={e => setSelectedClient(e.target.value)}>
                                        <option value="">Seleccionar cliente</option>
                                        {clients.map(client => (
                                            <option key={client.id} value={client.id}>{client.name}</option>
                                        ))}
                                    </Form.Control>
                                </Form.Group>
                            </Col>
                        </Row>
                        <Row className="mb-3">
                            <Col>
                                <Form.Group controlId="startDate">
                                    <Form.Label>Fecha de Inicio</Form.Label>
                                    <Form.Control type="date" value={dateRange.start} onChange={e => setDateRange({ ...dateRange, start: e.target.value })} />
                                </Form.Group>
                            </Col>
                            <Col>
                                <Form.Group controlId="endDate">
                                    <Form.Label>Fecha de Fin</Form.Label>
                                    <Form.Control type="date" value={dateRange.end} onChange={e => setDateRange({ ...dateRange, end: e.target.value })} />
                                </Form.Group>
                            </Col>
                        </Row>
                        <Row className="mb-3">
                            <Col>
                                <Form.Group controlId="chartType">
                                    <Form.Label>Tipo de Gráfico</Form.Label>
                                    <Form.Control as="select" value={chartType} onChange={e => setChartType(e.target.value)}>
                                        <option value="entries">Entradas</option>
                                        <option value="exits">Salidas</option>
                                        <option value="both">Ambos</option>
                                    </Form.Control>
                                </Form.Group>
                            </Col>
                            <Col>
                                <Form.Group controlId="xAxisGrouping">
                                    <Form.Label>Agrupar por</Form.Label>
                                    <Form.Control as="select" value={xAxisGrouping} onChange={e => setXAxisGrouping(e.target.value)}>
                                        <option value="articles">Artículos</option>
                                        <option value="clients">Clientes</option>
                                        <option value="dates">Fechas</option>
                                    </Form.Control>
                                </Form.Group>
                            </Col>
                            {xAxisGrouping === 'dates' && (
                                <Col>
                                    <Form.Group controlId="dateGrouping">
                                        <Form.Label>Periodo de Agrupación</Form.Label>
                                        <Form.Control as="select" value={dateGrouping} onChange={e => setDateGrouping(e.target.value)}>
                                            <option value="daily">Diario</option>
                                            <option value="biweekly">Quincenal</option>
                                            <option value="monthly">Mensual</option>
                                            <option value="yearly">Anual</option>
                                        </Form.Control>
                                    </Form.Group>
                                </Col>
                            )}
                        </Row>
                        <Button variant="primary" onClick={handleFilterChange}>Actualizar Gráfico</Button>
                    </Form>
                    <Bar data={data} />
                </div>
            </Collapse>
        </div>
    );
};

export default StockChart;

*****

src\services\api.js:

import axios from 'axios';

const API_URL = 'http://localhost:8000/api/';

// Configurar el token de autenticación para cada solicitud
axios.interceptors.request.use(
  config => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Token ${token}`;
    }
    return config;
  },
  error => {
    return Promise.reject(error);
  }
);

export const getArticles = () => axios.get(`${API_URL}articles/`);
export const getEntries = () => axios.get(`${API_URL}entries/`);
export const getExits = () => axios.get(`${API_URL}exits/`);
export const createEntry = (entry) => axios.post(`${API_URL}entries/`, entry);
export const createExit = (exit) => axios.post(`${API_URL}exits/`, exit);
export const getClients = () => axios.get(`${API_URL}clients/`);

*****
Resumen de la Implementación de Inicio de Sesión y Registro en la Aplicación

Tecnologías Utilizadas

Frontend: React

Backend: Django con Django Rest Framework

Autenticación: dj-rest-auth

Funcionalidades Implementadas

Registro de Usuarios


Se ha implementado un formulario de registro en React que permite a los usuarios crear una nueva cuenta.

El formulario envía una solicitud POST al endpoint de registro proporcionado por dj-rest-auth.

El backend maneja la creación del nuevo usuario y retorna un token de autenticación.

El token se almacena en localStorage en el navegador para mantener la sesión iniciada.


Inicio de Sesión


Se ha implementado un formulario de inicio de sesión en React que permite a los usuarios autenticarse.

El formulario envía una solicitud POST al endpoint de inicio de sesión de dj-rest-auth.

El backend autentica al usuario y retorna un token de autenticación.

El token se almacena en localStorage para mantener la sesión iniciada.


Protección de Rutas


Se ha creado un componente PrivateRoute en React que verifica la presencia del token en localStorage.

Si el token está presente, el usuario puede acceder a las rutas protegidas de la aplicación.

Si el token no está presente, el usuario es redirigido a la página de inicio de sesión.

Cierre de Sesión

Se ha implementado un botón de logout que permite a los usuarios cerrar su sesión.

Al hacer clic en el botón de logout, el token se elimina de localStorage y el usuario es redirigido a la página de inicio de sesión.


Duración de la Sesión


La duración del token y la validez de la sesión están determinadas por la configuración del backend en Django (no se ha implementado nox para controlarlo).

En esta implementación, la sesión dura mientras el token esté presente en localStorage y no se haya invalidado manualmente.


Detalles Específicos

Formulario de Registro:

Captura el nombre de usuario y la contraseña del nuevo usuario.

Envía una solicitud al backend para crear un nuevo usuario.

Almacena el token recibido en localStorage para mantener la sesión iniciada.

Formulario de Inicio de Sesión:

Captura el nombre de usuario y la contraseña del usuario existente.

Envía una solicitud al backend para autenticar al usuario.
Almacena el token recibido en localStorage para mantener la sesión iniciada.


Componente PrivateRoute:

Verifica si el token de autenticación está presente en localStorage.

Permite el acceso a las rutas protegidas si el token está presente.
Redirige a la página de inicio de sesión si el token no está presente.


Botón de Logout:

Elimina el token de localStorage al hacer clic.

Redirige al usuario a la página de inicio de sesión, cerrando efectivamente la sesión.


Conclusión

Hemos implementado un sistema de autenticación completo que incluye registro de usuarios, inicio de sesión, protección de rutas y cierre de sesión, 
utilizando React en el frontend y Django con dj-rest-auth en el backend. 
Este sistema asegura que solo los usuarios autenticados puedan acceder a ciertas partes de la aplicación, proporcionando una capa adicional de seguridad y control de acceso.

